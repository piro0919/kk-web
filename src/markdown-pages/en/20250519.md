---
slug: "/blog/20250519"
date: "2025-05-19"
title: "Programming Languages That Will (and Won't) Survive the Next 10 Years"
---

"Programming languages that will survive the next 10 years" — sounds like a bold title, right?

Articles like this are usually published by companies trying to push their own stacks, and honestly, I can’t be the only one thinking, _“Really though?”_

So in this post, I’d like to share my own perspective as a working frontend engineer. This list is based on both actual trends and future potential.

---

### Selection Criteria

- I asked ChatGPT for insight, but prioritized **future viability** over current usage
- Though my perspective is based on the Japanese tech scene, the list ended up being globally relevant
- I’ve tried to keep personal bias to a minimum (hopefully)

There are tons of languages out there, but if a language isn’t on this list… well, it probably doesn’t need to be.

Here’s how I’ve grouped them:

- Languages you absolutely want to know (High Recommendation)
- Niche but still useful in the right context (Medium)
- Languages still in the field, but not worth learning today (Low)

---

## 🟢 Languages You Can’t Go Wrong With (High Recommendation)

### JavaScript (TypeScript)

JavaScript continues to be a powerhouse — especially when paired with TypeScript.

In reality, very few projects write raw JavaScript anymore. TypeScript is the norm, and that’s what you’ll need in most modern environments.

From frontend UI to backend APIs, JavaScript/TypeScript dominates web development. The barrier to entry is low, it’s fun to write, and nearly every team uses it in some form.

That said, it's also easy to write _bad_ code with it — so solid fundamentals matter more than ever.

**Best For:** Web applications, UI development

---

### Python

If JavaScript is the face of the web, Python is the brain behind AI and data processing.

It’s a gentle language to learn, but don’t let that fool you — it’s incredibly powerful across domains like automation, data science, and machine learning.

The demand is high, the talent pool relatively small, and the hourly rates reflect that. Also, Python’s role in generative AI is only getting stronger.

**Best For:** AI, automation, data analysis

---

### Go

While slightly less flashy than the two above, Go is one of the most practical languages in use today.

It’s particularly good for backend systems where JavaScript might not be performant enough — that last 10% of high-throughput workloads.

Easy to learn, fast to execute, and used by many startups and SaaS companies in production.

**Best For:** APIs, infrastructure, backend services

---

## 🟡 Domain-Specific but Still Valuable (Medium Recommendation)

### C++

Let’s be honest: C++ is old. But it’s not going anywhere, especially in game development and high-performance computing.

You’ll find it powering game engines, embedded systems, and real-time simulations.

**Best For:** Game development, hardware control, real-time systems

---

### C＃

C# is alive and well thanks to Unity, and also has a solid foothold in enterprise apps.

It’s easier to learn than C++, and if you're interested in 3D game development, you’ll likely run into it.

**Best For:** Game development (Unity), Windows applications

---

### Kotlin & Swift

If you're building native apps, these are your go-to tools: Kotlin for Android, Swift for iOS.

While mobile app demand is slowly tapering off, it's far from disappearing — and these languages are essential for serious mobile devs.

**Best For:** Android and iOS app development

---

### Rust

In most backend situations, Node or Go will be sufficient. But for that final 1% where performance and safety are critical, Rust shines.

It’s adopted by major tech firms and delivers unmatched speed and memory safety — but it’s not easy to learn.

If you’re into low-level control, WASM, or CLI tooling, Rust is a great long-term bet.

**Best For:** Security-critical systems, WebAssembly, CLI tools

---

## 🔴 Still Seen in the Field, But Not Worth Learning Today (Low Recommendation)

### Java

Still deeply embedded in large enterprises. If you're joining a bank, government system, or insurance company, you’ll probably see Java.

That said, it’s rarely used for new projects anymore — and outside of maintenance, its future looks pretty stale.

### PHP

PHP still powers some major legacy systems, but the tide has clearly turned. There's little reason to learn it today unless you're maintaining an old codebase.

### Ruby

Ruby (and Rails) had its heyday — especially in Japan. But today, it’s mostly legacy.

It’s a great language from a design perspective, but there’s just not much demand for it anymore.

### Perl / VB.NET / Objective-C

Legacy only. These languages live on in aging codebases, but are otherwise irrelevant for new developers.

---

## 🤔 What to Choose Based on Your Interests

| Your Interest                   | Recommended Language(s)      |
| ------------------------------- | ---------------------------- |
| Want to build web services      | JavaScript (TypeScript)      |
| Interested in AI or automation  | Python                       |
| Want to join a startup          | Go / JavaScript (TypeScript) |
| Dream of making games           | C++ / C#                     |
| Want to build mobile apps       | Kotlin / Swift               |
| Curious about low-level systems | Rust                         |

---

## 🧠 Final Thoughts

I asked ChatGPT for its one-liner summary for new developers:

> "It depends on what you want to build, but if you're not sure — start with TypeScript or Python, and you'll probably be fine."

Honestly, I couldn’t agree more.

---

For the record, I only really write JavaScript (TypeScript), but I’m still managing to stay employed — thanks mostly to its massive demand.

The tech world keeps changing, and being a programmer means staying curious and always learning.

---

With the rise of AI, developers who only know things on a surface level are already being left behind.

It’s not an easy time to be in this field — but if you know _why_ you want to be a developer, and _what_ you want to build, I think you'll be just fine.

Maybe. Probably. Hopefully.
